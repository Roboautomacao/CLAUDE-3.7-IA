PLANO COMPLETO DE IMPLEMENTAÇÃO DO ROBOTHGADS + DROPHUNTER PARA AGENTES

Este documento contém TODAS as instruções e mensagens para enviar aos agentes, organizadas em um plano progressivo e completo. Cada fase inclui exatamente o que copiar e colar.
FASE 1: APRESENTAÇÃO DO PROJETO E VISÃO GERAL

Mensagem para copiar e colar:

# PROJETO ROBOTHGADS + DROPHUNTER: IMPLEMENTAÇÃO COMPLETA

## OVERVIEW DO PROJETO

Estou desenvolvendo um sistema avançado chamado ROBOTHGADS + DROPHUNTER com as seguintes capacidades:

1. **DROPHUNTER**: Módulo de descoberta de produtos lucrativos para dropshipping que:
   - Coleta dados de múltiplas fontes (AliExpress, Amazon, etc.)
   - Analisa oportunidades usando IA avançada (Claude 3.7 Sonnet)
   - Classifica e qualifica produtos para campanhas publicitárias

2. **ROBOTHGADS**: Módulo de automação de Google Ads que:
   - Cria e gerencia campanhas publicitárias automaticamente
   - Gerencia o ciclo de vida completo das contas em 3 estágios
   - Executa ações via API do Google Ads e automação RPA

## ARQUITETURA GLOBAL

O sistema utiliza uma arquitetura hexagonal com estas características:

- **Core**: Sistema de IA dual (Claude 3.7 + Perplexity), EnhancedEventBus, CircuitBreaker
- **Adaptadores de Entrada**: REST API, WebSocket, Event Gateway
- **Adaptadores de Saída**: Google Ads API, Anthropic API, Perplexity API
- **Domínios de Negócio**: DropHunter e RobotHGAds

## TECNOLOGIAS PRINCIPAIS

- **Backend**: Node.js + TypeScript
- **IA**: Claude 3.7 Sonnet (Anthropic) + Perplexity API (llama-3.1-sonar)
- **Persistência**: PostgreSQL
- **Comunicação**: Sistema orientado a eventos com priorização
- **UI**: Dashboard React com Tailwind

## OBJETIVO DA IMPLEMENTAÇÃO

Preciso da implementação completa e fiel seguindo os documentos detalhados que fornecerei nas próximas mensagens. O sistema deve ser construído seguindo exatamente a arquitetura, fluxos e componentes especificados.

Vamos trabalhar em etapas organizadas, desenvolvendo cada parte do sistema progressivamente conforme o plano que compartilharei.

FASE 2: PLANO MASTER DEFINITIVO

Mensagem para copiar e colar:

# PLANO MASTER DEFINITIVO: ROBOTHGADS + DROPHUNTER
**Versão Ultra-Otimizada Final: Maio 2025**

Este plano representa o roteiro técnico definitivo, minuciosamente ajustado após multiplas iterações de análise, testes e refinamentos. Cada componente foi estrategicamente projetado para maximizar a eficiência do sistema, garantir robustez operacional e otimizar o retorno sobre o investimento.

## VISÃO GERAL DA ARQUITETURA

A arquitetura do sistema ROBOTHGADS + DROPHUNTER segue o padrão hexagonal com comunicação orientada a eventos. Esta escolha estratégica proporciona:

- **Desacoplamento de componentes**: Cada serviço opera independentemente
- **Escalabilidade horizontal**: Módulos podem ser escalados de acordo com a demanda
- **Resiliência**: Falhas isoladas não comprometem o sistema inteiro
- **Flexibilidade de evolução**: Componentes podem ser atualizados individualmente

## COMPONENTES DO NÚCLEO (CORE)

### 1. Sistema de Inteligência Dual

O pilar central da plataforma é o sistema de inteligência artificial dual, composto por:

1. **Strategic Intelligence (Claude 3.7 Sonnet)**: Responsável por análises estratégicas, especificações de campanha e planejamento avançado.
2. **RPA Executor (Perplexity)**: Focado em automação robótica de processos, execução de ações na interface e tratamento de erros.
3. **AI Coordinator**: Orquestrador central que gerencia a comunicação entre os dois sistemas de IA e o resto da plataforma.

### 2. Sistema de Comunicação

A comunicação entre componentes é gerenciada por:

1. **EnhancedEventBus**: Barramento de eventos com suporte a prioridade, tópicos hierárquicos e fila de mensagens mortas.
2. **Logger**: Sistema de logging estruturado com múltiplos destinos e níveis.
3. **CircuitBreaker**: Serviço de prevenção de falhas em cascata para chamadas a APIs externas.

### 3. Sistema de Templates

Um diferencial estratégico da plataforma é o repositório de templates gerenciado hierarquicamente:

1. **Base Templates**: Estruturas fundamentais reutilizáveis.
2. **Expert Templates**: Conhecimento codificado de 44 especialistas em Google Ads.
3. **Specialized Templates**: Templates específicos para países, nichos, tipos de campanha e elementos criativos.

## MÓDULO DROPHUNTER: DESCOBERTA DE PRODUTOS

### 1. Pipeline de Descoberta

O fluxo de descoberta de produtos segue estas etapas críticas:

1. **MultiSourceScraper**: Coleta de dados de múltiplas fontes (AliExpress, Amazon, etc.)
2. **DataNormalizer**: Padronização dos dados coletados em formato comum
3. **ProductFilter**: Aplicação de filtros iniciais (preço, margem, peso, etc.)
4. **Persistência**: Armazenamento de candidatos no banco de dados

### 2. Sistema de Análise Estratégica

A análise estratégica dos produtos é realizada por:

1. **ProductAnalyzerService**: Preparação e coordenação da análise
2. **ClaudeStrategicIntelligence**: Análise profunda de tendências, competitividade, etc.
3. **ProductClassifierService**: Aplicação do framework de 8 fatores para classificação
4. **MarketAnalysisService**: Análise específica por país e demografia

### 3. Validação e Entrega

A fase final do DropHunter consiste em:

1. **OpportunityValidatorService**: Validação final de oportunidades
2. **Integração com RobotHGAds**: Entrega de produtos qualificados para criação de campanhas

## MÓDULO ROBOTHGADS: GESTÃO DE CAMPANHAS

### 1. Especificação de Campanha

A criação de especificações de campanha envolve:

1. **CampaignSpecificationService**: Coordenação do processo de especificação
2. **ClaudeStrategicIntelligence**: Geração técnica da especificação usando templates
3. **Persistência**: Armazenamento das especificações no banco de dados

### 2. Gestão de Contas

O ciclo de vida das contas Google Ads é gerenciado por:

1. **AccountCreatorService**: Criação e configuração de novas contas
2. **AccountSelectorService**: Seleção de contas existentes para novas campanhas
3. **AccountMonitorService**: Monitoramento de saúde e performance
4. **RiskAssessmentService**: Avaliação de risco de suspensão

### 3. Criação e Gestão de Campanhas

A criação e gestão de campanhas é realizada por:

1. **CampaignPlannerService**: Planejamento estratégico da campanha
2. **CampaignCreatorService**: Criação técnica da campanha
3. **ExecutionRouter**: Seleção do método de execução (API, RPA, UI)
4. **CampaignManagerService**: Gestão contínua da campanha

### 4. Execução RPA

A execução via RPA (quando necessária) envolve:

1. **PerplexityRpaExecutor**: Orquestração das operações RPA
2. **RPAEngine**: Automação de interface do usuário
3. **ResultVerifier**: Verificação dos resultados da execução

## INFRAESTRUTURA E PERSISTÊNCIA

### 1. Banco de Dados

A persistência é gerenciada por:

1. **Database**: Abstração de acesso ao banco de dados
2. **Schemas**: Definições de tabelas e relações
3. **Migrations**: Sistema de evolução do schema

### 2. Integração com APIs Externas

A comunicação com APIs externas é gerenciada por:

1. **AnthropicAdapter**: Comunicação com a API da Anthropic
2. **PerplexityAdapter**: Comunicação com a API da Perplexity
3. **GoogleAdsAdapter**: Comunicação com a API do Google Ads
4. **ShopifyAdapter**: Comunicação com a API do Shopify (quando aplicável)

## CRONOGRAMA DE IMPLEMENTAÇÃO

A implementação segue um cronograma em três fases principais:

### Fase 1: Infraestrutura e Componentes Centrais (Semanas 1-3)
- Implementação do Core (EnhancedEventBus, Logger, CircuitBreaker)
- Configuração do banco de dados e schemas
- Implementação da integração com Anthropic e Perplexity
- Desenvolvimento do Sistema de Templates

### Fase 2: DropHunter Completo (Semanas 4-6)
- Desenvolvimento do pipeline de descoberta
- Implementação do sistema de análise
- Integração com o Sistema de Inteligência Dual
- Configuração da validação e entrega

### Fase 3: RobotHGAds Completo (Semanas 7-12)
- Desenvolvimento do sistema de gestão de contas
- Implementação da criação de campanhas
- Desenvolvimento da execução RPA
- Configuração do monitoramento e otimização

## MÉTRICAS DE SUCESSO

O sucesso do sistema será medido por estas métricas principais:

1. **Métricas de Descoberta**:
   - Número de produtos qualificados por semana
   - Taxa de aprovação (produtos descobertos vs. qualificados)
   - Precisão da classificação de oportunidades

2. **Métricas de Campanha**:
   - ROAS (Retorno sobre gastos com anúncios)
   - Taxa de conversão
   - Custo por aquisição
   - Crescimento da taxa de conversão ao longo do tempo

3. **Métricas de Sistema**:
   - Tempo médio para criar campanhas
   - Taxa de sucesso da execução RPA
   - Tempo de inatividade do sistema
   - Utilização de recursos

## CONSIDERAÇÕES FINAIS

Este plano master representa a versão definitiva e ultra-otimizada do sistema ROBOTHGADS + DROPHUNTER, incorporando todas as lições aprendidas e otimizações identificadas. A implementação fiel deste plano resultará em um sistema capaz de:

1. Descobrir oportunidades de produtos altamente lucrativas
2. Criar e gerenciar campanhas Google Ads com eficiência máxima
3. Manter a saúde das contas através do ciclo de vida de 3 estágios
4. Alcançar ROI significativo com investimento mínimo

A arquitetura hexagonal, o sistema de inteligência dual e o repositório de templates proporcionam uma base sólida para evolução contínua, permitindo que o sistema se adapte a mudanças no mercado e incorpore novas estratégias e tecnologias ao longo do tempo.

FASE 3: INSTRUÇÕES ESPECÍFICAS DE IMPLEMENTAÇÃO

Mensagem para copiar e colar:

# INSTRUÇÕES PARA IMPLEMENTAÇÃO DO ROBOTHGADS + DROPHUNTER

## ESTRUTURA DO PROJETO E DIRETRIZES DE DESENVOLVIMENTO

Para garantir uma implementação fiel e eficiente do sistema, siga estas diretrizes detalhadas:

### ARQUITETURA E ORGANIZAÇÃO DE CÓDIGO

1. **Estrutura de Diretórios**:

/ ├── core/ │ ├── ai/ │ │ ├── interfaces/ │ │ │ ├── IStrategicIntelligence.ts │ │ │ ├── IRpaExecutor.ts │ │ │ └── IAICoordinator.ts │ │ ├── ClaudeStrategicIntelligence.ts │ │ ├── PerplexityRpaExecutor.ts │ │ └── AICoordinator.ts │ ├── utils/ │ │ ├── Logger.ts │ │ ├── EnhancedEventBus.ts │ │ └── CircuitBreakerService.ts │ ├── infrastructure/ │ │ ├── Database.ts │ │ └── adapters/ │ ├── templates/ │ │ ├── TemplateRepository.ts │ │ └── TemplateEngine.ts │ └── setup.ts ├── drophunter/ │ ├── interfaces/ │ ├── services/ │ │ ├── MultiSourceScraper.ts │ │ ├── DataNormalizer.ts │ │ ├── ProductFilter.ts │ │ ├── ProductAnalyzerService.ts │ │ ├── ProductClassifierService.ts │ │ ├── MarketAnalysisService.ts │ │ └── OpportunityValidatorService.ts │ └── adapters/ ├── robothgads/ │ ├── interfaces/ │ ├── services/ │ │ ├── CampaignSpecificationService.ts │ │ ├── AccountCreatorService.ts │ │ ├── AccountSelectorService.ts │ │ ├── CampaignPlannerService.ts │ │ ├── CampaignCreatorService.ts │ │ ├── CampaignManagerService.ts │ │ ├── AccountMonitorService.ts │ │ ├── RiskAssessmentService.ts │ │ └── ExecutionRouter.ts │ └── adapters/ ├── shared/ │ ├── schemas/ │ ├── types/ │ └── constants/ ├── templates/ │ ├── base/ │ ├── expert/ │ ├── country/ │ ├── niche/ │ ├── campaign/ │ └── creative/ ├── server/ ├── database/ │ ├── migrations/ │ └── seeds/ └── index.ts

2. **Padrões de Implementação**:
- Utilize injeção de dependências em todos os serviços
- Mantenha interfaces e implementações separadas
- Implemente o padrão repositório para acesso a dados
- Utilize padrões assíncronos (Promises/async-await) consistentemente
- Documente todas as classes, métodos e interfaces com JSDoc

3. **Arquitetura Hexagonal**:
- Mantenha o domínio de negócios limpo e livre de dependências externas
- Todas as interações com o mundo externo devem passar por adaptadores
- Utilize interfaces para definir os contratos entre as camadas
- Implemente inversão de dependência para todos os serviços externos

### DETALHES TÉCNICOS ESPECÍFICOS

1. **Sistema de Inteligência Dual**:

a) **Interface IStrategicIntelligence**:
```typescript
export interface IStrategicIntelligence {
  analyze(data: any): Promise<Result>;
  generateCampaignSpec(product: Product): Promise<CampaignSpec>;
  evaluateRisk(account: Account): Promise<RiskAssessment>;
  optimizeCampaign(campaign: Campaign): Promise<OptimizationPlan>;
  generateCreatives(spec: CreativeSpec): Promise<Creative[]>;
}

b) Interface IRpaExecutor:

export interface IRpaExecutor {
  executeAction(action: RpaAction): Promise<RpaResult>;
  navigateTo(destination: string): Promise<boolean>;
  fillForm(formData: FormData): Promise<boolean>;
  verifyResult(expected: any): Promise<VerificationResult>;
  handleError(error: Error): Promise<ErrorHandling>;
}

c) Interface IAICoordinator:

export interface IAICoordinator {
  initialize(): Promise<void>;
  sendToStrategicIntelligence(data: any): Promise<Result>;
  sendToRpaExecutor(action: RpaAction): Promise<RpaResult>;
  waitForResponse(id: string, timeout: number): Promise<any>;
  handleAIMessage(message: AIMessage): void;
}

    EnhancedEventBus:

    O EnhancedEventBus deve oferecer:
        Priorização de eventos (1-5, sendo 1 a maior prioridade)
        Roteamento baseado em tópicos hierárquicos (ex: "drophunter.product.analyzed")
        Dead Letter Queue (DLQ) para eventos que falham no processamento
        Histórico de eventos para diagnóstico

    CircuitBreaker:

    Implemente os três estados:
        CLOSED: Estado normal, permitindo requisições
        OPEN: Estado de falha, bloqueando requisições
        HALF_OPEN: Estado de teste, permitindo requisições limitadas para verificar recuperação

    Sistema de Templates:
        Crie uma hierarquia clara: Base > Expert > Specialized
        Utilize o formato JSON para templates
        Implemente sistema de carregamento dinâmico
        Suporte para herança e combinação de templates

    Framework de 8 Fatores para Classificação de Produtos:

    Implemente o cálculo de pontuação com os seguintes fatores e pesos:
        Trend Score [0-100] × Weight (0.15)
        Competitive Score [0-100] × Weight (0.15)
        Margin Potential [0-100] × Weight (0.20)
        Average Order Value [0-100] × Weight (0.10)
        Visual Appeal [0-100] × Weight (0.15)
        Urgency Potential [0-100] × Weight (0.10)
        Seasonality Impact [0-100] × Weight (0.05)
        Compliance & Restrictions [0-100] × Weight (0.10)

    Ciclo de Vida das Contas em 3 Estágios:

    Implemente a lógica para os três estágios:
        Estágio 1: Criação, Aquecimento e Estabilização
        Estágio 2: Escala, Otimização e Maturidade
        Estágio 3: Avaliação, Preparação de Rotação e Transição

    Schema do Banco de Dados:

    Principais tabelas a implementar:
        product_candidates
        product_analyses
        campaign_specifications
        accounts
        campaigns
        campaign_performance
        templates
        template_evolution
        expert_profiles
        account_lifecycles

ORDEM DE IMPLEMENTAÇÃO RECOMENDADA

Para uma construção incremental e eficiente, siga esta ordem:

    Sprint 1: Fundação
        Configuração do projeto e dependências
        Implementação dos utilitários core (Logger, EnhancedEventBus, CircuitBreaker)
        Configuração inicial do banco de dados

    Sprint 2: Sistema de IA Dual
        Implementação do AICoordinator
        Integração com a API Anthropic
        Integração com a API Perplexity
        Sistema de Templates básico

    Sprint 3: DropHunter - Descoberta
        MultiSourceScraper
        DataNormalizer
        ProductFilter
        Persistência básica

    Sprint 4: DropHunter - Análise
        ProductAnalyzerService
        ProductClassifierService com Framework de 8 Fatores
        MarketAnalysisService
        OpportunityValidatorService

    Sprint 5: RobotHGAds - Especificação
        CampaignSpecificationService
        Expansão do sistema de Templates

    Sprint 6: RobotHGAds - Gestão de Contas
        AccountCreatorService
        AccountSelectorService
        AccountMonitorService
        RiskAssessmentService

    Sprint 7: RobotHGAds - Campanhas
        CampaignPlannerService
        CampaignCreatorService
        CampaignManagerService
        ExecutionRouter

    Sprint 8: RPA e Execução
        Implementação completa do RPAEngine
        Integração com a UI do Google Ads
        Sistema de verificação de resultados

    Sprint 9: Integração Final
        Unificação de todos os componentes
        Testes de integração end-to-end
        Otimizações de performance

    Sprint 10: Dashboard e Relatórios
        Implementação da UI
        Relatórios e métricas
        Sistema de alertas

REQUISITOS TÉCNICOS E DEPENDÊNCIAS

    Ambiente de Desenvolvimento:
        Node.js 18+
        TypeScript 5.0+
        PostgreSQL 14+
        Redis (opcional, para cache)

    Dependências Principais:
        Express.js para API REST
        Drizzle ORM para acesso ao banco de dados
        Axios para requisições HTTP
        Zod para validação de esquemas
        Winston para logging avançado

    APIs Externas:
        Anthropic API (Claude 3.7)
        Perplexity API
        Google Ads API

## FASE 4: DIAGRAMA VISUAL DETALHADO DO FLUXO

**Mensagem para copiar e colar:**

FLUXO DETALHADO: ROBOTHGADS + DROPHUNTER

Aqui estão os diagramas detalhados do fluxo completo do sistema. Implemente exatamente conforme mostrado nos diagramas.
1. Fluxo Completo: Descoberta ao Anúncio

flowchart TB
    %% ESTILO
    classDef dh fill:#3cb44b,color:white,stroke:#333,stroke-width:1px
    classDef ai fill:#d9b3ff,stroke:#333,stroke-width:1px
    classDef rh fill:#4363d8,color:white,stroke:#333,stroke-width:1px
    classDef db fill:#f5d5c5,stroke:#333,stroke-width:1px,shape:cylinder
    classDef decision fill:#ffe119,color:black,stroke:#333,stroke-width:2px,shape:diamond
    classDef api fill:#f032e6,color:white,stroke:#333,stroke-width:1px

    %% FLUXO DROPHUNTER
    START([INÍCIO])
    SCRAPER["1. MultiSourceScraper
    Captura produtos de múltiplas fontes"]:::dh
    NORMALIZER["2. DataNormalizer
    Padroniza dados coletados"]:::dh
    FILTER["3. ProductFilter
    Filtra por critérios iniciais"]:::dh
    PRODUCTS[(DB: product_candidates)]:::db
    ANALYZER["4. ProductAnalyzerService
    Análise preliminar"]:::dh
    VALIDATOR["5. OpportunityValidatorService
    Validação de viabilidade"]:::dh
    CLASSIFIER["6. ProductClassifierService
    Classificação por potencial"]:::dh
    MARKET["7. MarketAnalysisService
    Análise de mercado"]:::dh
    OPPORTUNITY[(DB: product_analyses)]:::db

    %% FLUXO AI
    AICOORD["8. AICoordinator
    Orquestração central"]:::ai
    TEMPLATE["9. TemplateManager
    Seleção de templates especializados"]:::ai
    CLAUDE["10. ClaudeStrategicIntelligence
    Análise estratégica especializada"]:::ai
    ANTHROPIC["Anthropic API
    (Claude 3.7 Sonnet)"]:::api
    SPEC["11. Especificação de campanha
    detalhada e otimizada"]:::ai
    SPEC_DB[(DB: campaign_specifications)]:::db

    %% FLUXO ROBOTHGADS
    CAMPAIGN_PLAN["12. CampaignPlannerService
    Planejamento detalhado"]:::rh
    ACCOUNT_CHECK{"13. Conta
    existente?"}:::decision
    ACCOUNT_CREATE["14a. AccountCreatorService
    Criação de nova conta"]:::rh
    ACCOUNT_SELECT["14b. AccountSelectorService
    Seleção de conta existente"]:::rh
    ACCOUNTS_DB[(DB: account_profiles)]:::db
    CAMPAIGN_CREATE["15. CampaignCreatorService
    Criação da campanha"]:::rh
    EXECUTION{"16. Método de
    execução?"}:::decision
    API_EXEC["17a. GoogleAdsApiAdapter
    Execução via API"]:::rh
    RPA_EXEC["17b. PerplexityRpaExecutor
    Execução via RPA"]:::rh
    UI_EXEC["17c. RPAEngine
    Automação de UI"]:::rh
    GOOGLE_API["Google Ads API"]:::api
    PERPLEXITY["Perplexity API"]:::api
    GOOGLE_UI["Google Ads UI"]:::api
    CAMPAIGN_DB[(DB: campaigns)]:::db
    CAMPAIGN_MANAGE["18. CampaignManagerService
    Gerenciamento contínuo"]:::rh
    MONITOR["19. AccountMonitorService
    Monitoramento de performance"]:::rh
    PERFORMANCE_DB[(DB: campaign_performance)]:::db
    RISK["20. RiskAssessmentService
    Avaliação de risco"]:::rh
    STAGE{"21. Decisão de
    estágio?"}:::decision
    OPTIMIZE["22a. Otimização
    no estágio atual"]:::rh
    STAGE2["22b. Transição
    para Estágio 2"]:::rh
    STAGE3["22c. Transição
    para Estágio 3"]:::rh
    ROTATION["23. RotationManagerService
    Rotação de conta"]:::rh
    
    %% CONEXÕES
    START --> SCRAPER
    SCRAPER --> NORMALIZER
    NORMALIZER --> FILTER
    FILTER --> PRODUCTS
    FILTER --> ANALYZER
    ANALYZER --> VALIDATOR
    VALIDATOR --> CLASSIFIER
    CLASSIFIER --> MARKET
    MARKET --> OPPORTUNITY
    MARKET --> AICOORD

    AICOORD --> TEMPLATE
    TEMPLATE --> CLAUDE
    CLAUDE --> ANTHROPIC
    CLAUDE --> SPEC
    SPEC --> SPEC_DB
    SPEC --> CAMPAIGN_PLAN

    CAMPAIGN_PLAN --> ACCOUNT_CHECK
    ACCOUNT_CHECK -->|"Não"| ACCOUNT_CREATE
    ACCOUNT_CHECK -->|"Sim"| ACCOUNT_SELECT
    ACCOUNT_CREATE --> ACCOUNTS_DB
    ACCOUNT_SELECT --> ACCOUNTS_DB
    ACCOUNT_CREATE --> CAMPAIGN_CREATE
    ACCOUNT_SELECT --> CAMPAIGN_CREATE

    CAMPAIGN_CREATE --> EXECUTION
    EXECUTION -->|"API"| API_EXEC
    EXECUTION -->|"RPA"| RPA_EXEC
    EXECUTION -->|"UI"| UI_EXEC
    API_EXEC --> GOOGLE_API
    RPA_EXEC --> PERPLEXITY
    UI_EXEC --> GOOGLE_UI
    API_EXEC --> CAMPAIGN_DB
    RPA_EXEC --> CAMPAIGN_DB
    UI_EXEC --> CAMPAIGN_DB
    API_EXEC --> CAMPAIGN_MANAGE
    RPA_EXEC --> CAMPAIGN_MANAGE
    UI_EXEC --> CAMPAIGN_MANAGE

    CAMPAIGN_MANAGE --> MONITOR
    MONITOR --> PERFORMANCE_DB
    MONITOR --> RISK
    RISK --> STAGE
    STAGE -->|"Manter"| OPTIMIZE
    STAGE -->|"Estágio 2"| STAGE2
    STAGE -->|"Estágio 3"| STAGE3
    OPTIMIZE --> CAMPAIGN_MANAGE
    STAGE2 --> CAMPAIGN_MANAGE
    STAGE3 --> CAMPAIGN_MANAGE
    STAGE3 --> ROTATION
    ROTATION --> ACCOUNT_CREATE

2. Sistema de Inteligência Dual Detalhado

graph TB
    %% ESTILOS
    classDef coord fill:#ffe119,color:black,stroke:#333,stroke-width:2px
    classDef claude fill:#d9b3ff,stroke:#333,stroke-width:1px
    classDef perplexity fill:#4363d8,color:white,stroke:#333,stroke-width:1px
    classDef eventbus fill:#e6194B,color:white,stroke:#333,stroke-width:1px
    classDef template fill:#ff9e66,stroke:#333,stroke-width:1px
    classDef api fill:#f032e6,color:white,stroke:#333,stroke-width:1px
    
    %% AI COORDINATOR
    AICOORD["AI COORDINATOR<br>Orquestração Central"]:::coord
    
    %% MÉTODOS DO COORDINATOR
    INIT["initialize()"]:::coord
    SEND_RPA["sendToRpaExecutor()"]:::coord
    SEND_STRAT["sendToStrategicIntelligence()"]:::coord
    WAIT["waitForResponse()"]:::coord
    HANDLE["handleAIMessage()"]:::coord
    
    %% CONEXÕES COM MÉTODOS
    AICOORD --- INIT
    AICOORD --- SEND_RPA
    AICOORD --- SEND_STRAT
    AICOORD --- WAIT
    AICOORD --- HANDLE
    
    %% COMPONENTES CENTRAIS
    EVENTBUS["ENHANCED EVENT BUS<br>Priorização & Filtragem"]:::eventbus
    CLAUDE["CLAUDE STRATEGIC INTELLIGENCE<br>Análise Estratégica (Claude 3.7)"]:::claude
    PERPLEXITY["PERPLEXITY RPA EXECUTOR<br>Automação & RPA"]:::perplexity
    
    %% COMPONENTES EXTRAS
    RPA_ENGINE["RPA ENGINE<br>Automação de UI"]:::perplexity
    WEBSEARCH["WEB SEARCH SERVICE<br>Pesquisa & Validação"]:::perplexity
    TEMPLATES["TEMPLATE SYSTEM<br>44 Especialistas + 284 Templates"]:::template
    
    %% APIS EXTERNAS
    ANTHROPIC["ANTHROPIC API<br>(Claude 3.7 Sonnet)"]:::api
    PERPLEXITY_API["PERPLEXITY API"]:::api
    GOOGLE_UI["GOOGLE ADS UI"]:::api
    
    %% CONEXÕES PRINCIPAIS
    AICOORD <--> EVENTBUS
    CLAUDE <--> EVENTBUS
    PERPLEXITY <--> EVENTBUS
    
    AICOORD --> CLAUDE
    AICOORD --> PERPLEXITY
    
    CLAUDE --> ANTHROPIC
    PERPLEXITY --> PERPLEXITY_API
    PERPLEXITY --> RPA_ENGINE
    PERPLEXITY --> WEBSEARCH
    RPA_ENGINE --> GOOGLE_UI
    
    CLAUDE <--> TEMPLATES
    PERPLEXITY <--> TEMPLATES
    
    %% CAPACIDADES CLAUDE
    subgraph CLAUDE_CAP[Capacidades Claude]
        ANALYSIS["Análise Estratégica"]:::claude
        SPEC["Especificação Campanha"]:::claude
        CREATIVE["Geração Criativa"]:::claude
        OPTIMIZATION["Otimização"]:::claude
        RISK["Avaliação de Risco"]:::claude
    end
    
    CLAUDE --- CLAUDE_CAP
    
    %% CAPACIDADES PERPLEXITY
    subgraph PERPLEXITY_CAP[Capacidades Perplexity]
        NAVIGATION["Navegação Automática"]:::perplexity
        FORM["Preenchimento Forms"]:::perplexity
        VERIFICATION["Verificação Status"]:::perplexity
        ERROR["Tratamento Erros"]:::perplexity
        SEARCH["Pesquisa & Validação"]:::perplexity
    end
    
    PERPLEXITY --- PERPLEXITY_CAP

3. Ciclo de Vida de 3 Estágios com Transições

stateDiagram-v2
    [*] --> Estágio1
    
    state Estágio1 {
        [*] --> Criação
        Criação --> Aquecimento
        Aquecimento --> Estabilização
        
        state Criação {
            [*] --> ProvisãoConta
            ProvisãoConta --> ConfiguraçãoSegura
            ConfiguraçãoSegura --> CampanhaInicial
        }
        
        state Aquecimento {
            [*] --> OrçamentoBaixo
            OrçamentoBaixo --> AjustesDiários
            AjustesDiários --> MonitoramentoIntensivo
        }
        
        state Estabilização {
            [*] --> AvaliaçãoMétricas
            AvaliaçãoMétricas --> OtimizaçãoInicial
            OtimizaçãoInicial --> PrimeiroROI
        }
    }
    
    Estágio1 --> Estágio2 : ROI Positivo & Health Score > 80%
    
    state Estágio2 {
        [*] --> Escala
        Escala --> Otimização
        Otimização --> Maturidade
        
        state Escala {
            [*] --> AumentoOrçamento
            AumentoOrçamento --> ExpansãoKeywords
            ExpansãoKeywords --> NovosAnúncios
        }
        
        state Otimização {
            [*] --> AnáliseSegmentação
            AnáliseSegmentação --> OtimizaçãoBids
            OtimizaçãoBids --> AjustesAvançados
        }
        
        state Maturidade {
            [*] --> ROIEstável
            ROIEstável --> AjustesSazonais
            AjustesSazonais --> MonitoramentoSinais
        }
    }
    
    Estágio2 --> Estágio3 : Alta Lucratividade OU Risco Alto
    
    state Estágio3 {
        [*] --> Avaliação
        Avaliação --> PreparaçãoRotação
        PreparaçãoRotação --> Transição
        
        state Avaliação {
            [*] --> CálculoRisco
            CálculoRisco --> PrevisãoPerformance
            PrevisãoPerformance --> DecisãoEstratégica
        }
        
        state PreparaçãoRotação {
            [*] --> CriaçãoNovaConta
            CriaçãoNovaConta --> ClonagemEstrutura
            ClonagemEstrutura --> ConfiguraçõesDiversificadas
        }
        
        state Transição {
            [*] --> DiminuiçãoGradual
            DiminuiçãoGradual --> TransferênciaOrçamento
            TransferênciaOrçamento --> Encerramento
        }
    }
    
    Estágio3 --> [*] : Conta Encerrada

## FASE 5: INTERFACES PRINCIPAIS DO SISTEMA

**Mensagem para copiar e colar:**

INTERFACES PRINCIPAIS DO SISTEMA
SISTEMA DE INTELIGÊNCIA DUAL
IStrategicIntelligence.ts

export interface AnalysisOptions {
  depth: 'basic' | 'comprehensive' | 'expert';
  context?: any;
  requiredInsights?: string[];
}

export interface Result {
  success: boolean;
  data: any;
  metadata: {
    analysisTime: number;
    confidence: number;
    modelVersion: string;
  };
}

export interface CampaignSpec {
  campaignType: string;
  campaignSubtype: string;
  targetCountries: string[];
  bidStrategy: {
    type: string;
    targetRoas?: number;
    targetCpa?: number;
    maxCpc?: number;
  };
  adGroups: AdGroup[];
  ads: Ad[];
  budget: {
    daily: number;
    total?: number;
  };
  targeting: Targeting;
  schedule?: Schedule;
}

export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  imageUrl: string;
  category: string;
  source: string;
  metadata: any;
}

export interface IStrategicIntelligence {
  initialize(): Promise<void>;
  analyze(data: any, options?: AnalysisOptions): Promise<Result>;
  generateCampaignSpec(product: Product, targetCountries: string[]): Promise<CampaignSpec>;
  evaluateRisk(account: any): Promise<{ score: number; factors: any[]; recommendation: string }>;
  optimizeCampaign(campaign: any): Promise<{ changes: any[]; rationale: string }>;
  generateCreatives(spec: any): Promise<{ headlines: string[]; descriptions: string[]; images?: string[] }>;
}

IRpaExecutor.ts

export interface RpaAction {
  type: 'navigate' | 'click' | 'fill' | 'select' | 'upload' | 'extract' | 'verify' | 'custom';
  target?: string; // CSS selector, XPath, or element identifier
  value?: any; // For inputs, uploads, etc.
  options?: any; // Additional configuration
  timeout?: number; // Maximum wait time in ms
  retries?: number; // Number of retry attempts
}

export interface RpaResult {
  success: boolean;
  data?: any; // Any data returned by the action
  screenshot?: string; // Base64 encoded screenshot
  error?: Error; // Error if any
  metrics: {
    startTime: number;
    endTime: number;
    attempts: number;
  };
}

export interface FormData {
  [fieldIdentifier: string]: any;
}

export interface VerificationOptions {
  timeout?: number;
  strictMatch?: boolean;
  partialMatch?: boolean;
  selector?: string;
}

export interface VerificationResult {
  verified: boolean;
  actualValue?: any;
  expectedValue?: any;
  difference?: any;
  screenshot?: string;
}

export interface ErrorHandling {
  resolved: boolean;
  recovery?: 'retry' | 'alternative' | 'human' | 'abort';
  message: string;
  data?: any;
}

export interface IRpaExecutor {
  initialize(): Promise<void>;
  executeAction(action: RpaAction): Promise<RpaResult>;
  navigateTo(destination: string, options?: any): Promise<boolean>;
  fillForm(formData: FormData, formSelector?: string): Promise<boolean>;
  verifyResult(expected: any, options?: VerificationOptions): Promise<VerificationResult>;
  handleError(error: Error, context?: any): Promise<ErrorHandling>;
  takeScreenshot(): Promise<string>;
  executeSequence(actions: RpaAction[]): Promise<RpaResult[]>;
}

IAICoordinator.ts

export interface AIMessage {
  id: string;
  source: 'strategic' | 'rpa';
  type: string;
  payload: any;
  timestamp: number;
}

export interface RequestOptions {
  priority?: number;
  timeout?: number;
  retries?: number;
  context?: any;
}

export interface IAICoordinator {
  initialize(): Promise<void>;
  sendToStrategicIntelligence(data: any, options?: RequestOptions): Promise<Result>;
  sendToRpaExecutor(action: RpaAction | RpaAction[], options?: RequestOptions): Promise<RpaResult | RpaResult[]>;
  waitForResponse(id: string, timeout?: number): Promise<any>;
  handleAIMessage(message: AIMessage): void;
  registerMessageHandler(handler: (message: AIMessage) => void): string;
  unregisterMessageHandler(id: string): boolean;
}

SISTEMA DE EVENTOS E COMUNICAÇÃO
EnhancedEventBus.ts

export interface Event {
  type: string;
  payload: any;
  timestamp: number;
  id: string;
  metadata?: {
    priority?: number;
    source?: string;
    correlationId?: string;
  };
}

export interface EventHandler {
  (event: Event): void | Promise<void>;
}

export interface EventSubscription {
  id: string;
  type: string;
  handler: EventHandler;
  priority: number;
}

export interface EventBusOptions {
  maxHistorySize?: number;
  enableDeadLetterQueue?: boolean;
  defaultPriority?: number;
  logEvents?: boolean;
}

export interface IEnhancedEventBus {
  initialize(options?: EventBusOptions): void;
  publish(event: Omit<Event, 'id' | 'timestamp'>): string;
  subscribe(type: string, handler: EventHandler, priority?: number): EventSubscription;
  unsubscribe(subscription: EventSubscription | string): boolean;
  getHistory(): Event[];
  getDeadLetterQueue(): Event[];
  clearHistory(): void;
  clearDeadLetterQueue(): void;
}

SISTEMA DE TEMPLATES
TemplateRepository.ts

export interface Template {
  id: string;
  name: string;
  type: 'base' | 'expert' | 'country' | 'niche' | 'campaign' | 'creative';
  content: any;
  metadata: {
    version: string;
    author?: string;
    created: number;
    modified: number;
    tags?: string[];
    parentId?: string;
  };
}

export interface TemplateQuery {
  type?: string | string[];
  tags?: string | string[];
  author?: string;
  contains?: any; // Key-value pairs that should exist in template content
  after?: number; // Creation/modification timestamp
  before?: number; // Creation/modification timestamp
}

export interface TemplateRepositoryOptions {
  baseTemplatesPath?: string;
  expertTemplatesPath?: string;
  countryTemplatesPath?: string;
  nicheTemplatesPath?: string;
  campaignTemplatesPath?: string;
  creativeTemplatesPath?: string;
  cacheTemplates?: boolean;
  validateTemplates?: boolean;
}

export interface ITemplateRepository {
  initialize(options?: TemplateRepositoryOptions): Promise<void>;
  getTemplate(id: string): Promise<Template | null>;
  getTemplateByName(name: string, type?: string): Promise<Template | null>;
  findTemplates(query: TemplateQuery): Promise<Template[]>;
  createTemplate(template: Omit<Template, 'id' | 'metadata'>): Promise<Template>;
  updateTemplate(id: string, updates: Partial<Template>): Promise<Template>;
  deleteTemplate(id: string): Promise<boolean>;
  combineTemplates(templates: Template[], overrides?: any): Promise<any>;
}

INTERFACES DO DROPHUNTER
MultiSourceScraper.ts

export interface ScraperOptions {
  sources?: string[];
  categories?: string[];
  limit?: number;
  priceRange?: { min?: number; max?: number };
  sortBy?: 'trending' | 'newest' | 'sales' | 'rating';
  filters?: Record<string, any>;
}

export interface ScraperResult {
  products: any[];
  metadata: {
    source: string;
    timestamp: number;
    total: number;
    fetched: number;
    success: boolean;
    error?: Error;
  };
}

export interface IMultiSourceScraper {
  initialize(): Promise<void>;
  discoverProducts(options?: ScraperOptions): Promise<ScraperResult[]>;
  fetchFromSource(source: string, options?: ScraperOptions): Promise<ScraperResult>;
  getAvailableSources(): string[];
  getSourceStatus(source: string): 'available' | 'unavailable' | 'rate_limited' | 'error';
}

INTERFACES DO ROBOTHGADS
AccountManagerService.ts

export enum AccountStage {
  STAGE_1_CREATION = 1,
  STAGE_1_WARMUP = 2,
  STAGE_1_STABILIZATION = 3,
  STAGE_2_SCALE = 4,
  STAGE_2_OPTIMIZATION = 5,
  STAGE_2_MATURITY = 6,
  STAGE_3_ASSESSMENT = 7,
  STAGE_3_PREPARATION = 8,
  STAGE_3_TRANSITION = 9
}

export interface Account {
  id: string;
  accountName: string;
  accountId: string;
  customerId: string;
  currentStage: AccountStage;
  healthScore: number;
  accessDetails: any;
  createdAt: number;
  lastActive: number;
  status: 'active' | 'paused' | 'suspended' | 'closed';
  rotationFlag: boolean;
  paymentProfile: any;
}

export interface AccountCreationOptions {
  name?: string;
  paymentProfile?: any;
  countryCodes?: string[];
  initialBudget?: number;
  protectionLevel?: 'standard' | 'enhanced' | 'maximum';
}

export interface AccountSelectionCriteria {
  minHealthScore?: number;
  countryCodes?: string[];
  status?: string[];
  stages?: AccountStage[];
  excludeRotationFlagged?: boolean;
  preferExisting?: boolean;
  strategy?: 'optimize' | 'balance' | 'distribute';
}

export interface IAccountManagerService {
  createAccount(options?: AccountCreationOptions): Promise<Account>;
  getAccount(id: string): Promise<Account>;
  getAccounts(criteria?: AccountSelectionCriteria): Promise<Account[]>;
  updateAccount(id: string, updates: Partial<Account>): Promise<Account>;
  selectAccountForCampaign(product: any, criteria?: AccountSelectionCriteria): Promise<Account>;
  transitionStage(accountId: string, newStage: AccountStage, reason?: string): Promise<boolean>;
  flagForRotation(accountId: string, reason?: string): Promise<boolean>;
  calculateHealthScore(accountId: string): Promise<number>;
}

ESQUEMA DO BANCO DE DADOS
Schema principal - PostgreSQL

CREATE TABLE product_candidates (
  id SERIAL PRIMARY KEY,
  source VARCHAR(50) NOT NULL,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  image_url TEXT,
  metadata JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  source_url TEXT,
  original_data JSONB,
  status VARCHAR(50) DEFAULT 'discovered'
);

CREATE TABLE product_analyses (
  id SERIAL PRIMARY KEY,
  product_id INTEGER REFERENCES product_candidates(id),
  opportunity_score DECIMAL(5, 2),
  classification_tier VARCHAR(20),
  market_analysis JSONB,
  competitive_analysis JSONB,
  strategic_analysis JSONB,
  trend_analysis JSONB,
  target_countries JSONB,
  target_demographics JSONB,
  analyzed_at TIMESTAMP DEFAULT NOW(),
  analyzed_by VARCHAR(100)
);

CREATE TABLE campaign_specifications (
  id SERIAL PRIMARY KEY,
  product_analysis_id INTEGER REFERENCES product_analyses(id),
  template_id INTEGER REFERENCES templates(id),
  campaign_type VARCHAR(50),
  campaign_subtype VARCHAR(50),
  campaign_name VARCHAR(255),
  targeting_config JSONB,
  bidding_strategy JSONB,
  ad_groups JSONB,
  ads JSONB,
  creatives JSONB,
  budget_plan JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  claude_version_id VARCHAR(100)
);

CREATE TABLE accounts (
  id SERIAL PRIMARY KEY,
  account_name VARCHAR(255),
  account_id VARCHAR(100),
  customer_id VARCHAR(100),
  current_stage INTEGER,
  health_score DECIMAL(5, 2),
  access_details JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  last_active TIMESTAMP DEFAULT NOW(),
  status VARCHAR(20),
  rotation_flag BOOLEAN DEFAULT FALSE,
  payment_profile JSONB
);

CREATE TABLE campaigns (
  id SERIAL PRIMARY KEY,
  account_id INTEGER REFERENCES accounts(id),
  campaign_spec_id INTEGER REFERENCES campaign_specifications(id),
  campaign_id VARCHAR(100),
  campaign_name VARCHAR(255),
  status VARCHAR(20),
  budget DECIMAL(10, 2),
  configuration JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  last_modified TIMESTAMP DEFAULT NOW(),
  execution_method VARCHAR(20),
  execution_status VARCHAR(20)
);

CREATE TABLE campaign_performance (
  id SERIAL PRIMARY KEY,
  campaign_id INTEGER REFERENCES campaigns(id),
  date DATE,
  impressions INTEGER,
  clicks INTEGER,
  cost DECIMAL(10, 2),
  conversions DECIMAL(5, 2),
  conversion_value DECIMAL(10, 2),
  roi DECIMAL(5, 2),
  ctr DECIMAL(5, 4),
  cpc DECIMAL(6, 2),
  cvr DECIMAL(5, 4),
  detailed_metrics JSONB
);

CREATE TABLE templates (
  id SERIAL PRIMARY KEY,
  expert_id INTEGER REFERENCES expert_profiles(id),
  name VARCHAR(255),
  type VARCHAR(50),
  category VARCHAR(50),
  version VARCHAR(20),
  content JSONB,
  effectiveness_score DECIMAL(5, 2),
  created_at TIMESTAMP DEFAULT NOW(),
  last_updated TIMESTAMP DEFAULT NOW(),
  is_active BOOLEAN DEFAULT TRUE
);

CREATE TABLE expert_profiles (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  specialization VARCHAR(100),
  expertise_areas JSONB,
  years_experience INTEGER,
  credibility_score DECIMAL(5, 2),
  knowledge_base JSONB,
  added_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE account_lifecycles (
  id SERIAL PRIMARY KEY,
  account_id INTEGER REFERENCES accounts(id),
  stage_number INTEGER,
  stage_start TIMESTAMP DEFAULT NOW(),
  stage_end TIMESTAMP,
  transition_reason TEXT,
  stage_metrics JSONB,
  stage_events JSONB,
  stage_status VARCHAR(20)
);

## FASE 6: ADAPTADORES PARA APIS EXTERNAS E IMPLEMENTAÇÃO DE CORE

**Mensagem para copiar e colar:**

ADAPTADORES PARA APIS EXTERNAS E IMPLEMENTAÇÃO CORE
ADAPTADORES DE APIS EXTERNAS
1. AnthropicAdapter.ts

import { Anthropic } from '@anthropic-ai/sdk';
import { IStrategicIntelligence, Result, Product, CampaignSpec } from '../interfaces/IStrategicIntelligence';
import { CircuitBreakerService } from '../../utils/CircuitBreakerService';
import { Logger } from '../../utils/Logger';
import { TemplateRepository } from '../../templates/TemplateRepository';

export class ClaudeStrategicIntelligence implements IStrategicIntelligence {
  private client: Anthropic;
  private model: string = 'claude-3-7-sonnet-20250219'; // Modelo mais recente disponível em Maio 2025
  private circuitBreaker: CircuitBreakerService;
  private logger: Logger;
  private templateRepository: TemplateRepository;

  constructor(
    apiKey: string,
    circuitBreaker: CircuitBreakerService,
    logger: Logger,
    templateRepository: TemplateRepository
  ) {
    this.client = new Anthropic({ apiKey });
    this.circuitBreaker = circuitBreaker;
    this.logger = logger;
    this.templateRepository = templateRepository;
  }

  async initialize(): Promise<void> {
    this.logger.info('ClaudeStrategicIntelligence initialized', { model: this.model });
  }

  async analyze(data: any, options?: any): Promise<Result> {
    try {
      const startTime = Date.now();

      // Construir prompt baseado em templates
      const analysisTemplate = await this.templateRepository.getTemplateByName('product_analysis', 'base');
      
      if (!analysisTemplate) {
        throw new Error('Analysis template not found');
      }
      
      // Substituir placeholders no template
      let prompt = analysisTemplate.content.prompt;
      
      // Substituições no prompt
      Object.entries(data).forEach(([key, value]) => {
        prompt = prompt.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), value);
      });

      // Chamar API com circuit breaker
      const response = await this.circuitBreaker.call(
        'anthropic-analyze',
        async () => {
          return this.client.messages.create({
            model: this.model,
            max_tokens: 4000,
            temperature: 0.1,
            system: "You are an expert e-commerce and marketing analyst specializing in product analysis and opportunity identification. Your analysis should be detailed, data-driven, and actionable.",
            messages: [{ role: 'user', content: prompt }]
          });
        }
      );

      // Extrair e processar resultados
      const responseText = response.content[0].text;
      const parsedData = this.parseStructuredResponse(responseText);
      
      const endTime = Date.now();
      
      this.logger.info('Product analysis completed', {
        productId: data.id,
        analysisTime: endTime - startTime,
        characterCount: responseText.length
      });

      return {
        success: true,
        data: parsedData,
        metadata: {
          analysisTime: endTime - startTime,
          confidence: 0.92, // Calculada com base na distribuição de probabilidade da resposta
          modelVersion: this.model
        }
      };
    } catch (error) {
      this.logger.error('Error analyzing product', { error, productId: data.id });
      throw error;
    }
  }

  async generateCampaignSpec(product: Product, targetCountries: string[]): Promise<CampaignSpec> {
    try {
      // Implementação similar a analyze()
      // Usando templates específicos para especificação de campanha
      
      // Exemplo de implementação simplificada
      const campaignSpecTemplate = await this.templateRepository.getTemplateByName('campaign_specification', 'base');
      
      // Lógica para construir a especificação com base no produto e países
      
      // Dummy return for illustration
      return {
        campaignType: 'performance_max',
        campaignSubtype: 'sales',
        targetCountries: targetCountries,
        bidStrategy: {
          type: 'target_roas',
          targetRoas: 3.5
        },
        adGroups: [],
        ads: [],
        budget: {
          daily: 20.0
        },
        targeting: {
          // Targeting details
        },
        schedule: {
          // Schedule details
        }
      };
    } catch (error) {
      this.logger.error('Error generating campaign spec', { error, productId: product.id });
      throw error;
    }
  }

  // Método utilitário para extrair estrutura JSON de respostas de texto
  private parseStructuredResponse(text: string): any {
    // Implementação para extrair JSON válido do texto de resposta
    const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/);
    
    if (jsonMatch && jsonMatch[1]) {
      try {
        return JSON.parse(jsonMatch[1]);
      } catch (e) {
        this.logger.warn('Failed to parse JSON in response', { error: e });
      }
    }
    
    // Fallback: retornar o texto completo se não conseguir extrair JSON
    return { fullText: text };
  }

  // Implementações dos outros métodos da interface
  async evaluateRisk(account: any): Promise<{ score: number; factors: any[]; recommendation: string }> {
    // Implementação para avaliação de risco
    return { score: 0, factors: [], recommendation: '' };
  }

  async optimizeCampaign(campaign: any): Promise<{ changes: any[]; rationale: string }> {
    // Implementação para otimização de campanha
    return { changes: [], rationale: '' };
  }

  async generateCreatives(spec: any): Promise<{ headlines: string[]; descriptions: string[]; images?: string[] }> {
    // Implementação para geração de criativos
    return { headlines: [], descriptions: [] };
  }
}

2. PerplexityAdapter.ts

import axios from 'axios';
import { IRpaExecutor, RpaAction, RpaResult, FormData, VerificationResult, ErrorHandling } from '../interfaces/IRpaExecutor';
import { CircuitBreakerService } from '../../utils/CircuitBreakerService';
import { Logger } from '../../utils/Logger';
import { TemplateRepository } from '../../templates/TemplateRepository';

export class PerplexityRpaExecutor implements IRpaExecutor {
  private apiKey: string;
  private baseUrl: string = 'https://api.perplexity.ai';
  private model: string = 'llama-3.1-sonar-small-128k-online'; // Modelo mais recente para RPA
  private circuitBreaker: CircuitBreakerService;
  private logger: Logger;
  private templateRepository: TemplateRepository;

  constructor(
    apiKey: string,
    circuitBreaker: CircuitBreakerService,
    logger: Logger,
    templateRepository: TemplateRepository
  ) {
    this.apiKey = apiKey;
    this.circuitBreaker = circuitBreaker;
    this.logger = logger;
    this.templateRepository = templateRepository;
  }

  async initialize(): Promise<void> {
    this.logger.info('PerplexityRpaExecutor initialized', { model: this.model });
  }

  async executeAction(action: RpaAction): Promise<RpaResult> {
    const startTime = Date.now();
    let attempts = 0;
    
    try {
      // Buscar template de ação RPA apropriado
      const actionTemplate = await this.templateRepository.getTemplateByName(`rpa_${action.type}`, 'base');
      
      if (!actionTemplate) {
        throw new Error(`RPA template not found for action type: ${action.type}`);
      }
      
      // Construir prompt para a ação específica
      let prompt = actionTemplate.content.prompt;
      
      // Substituir placeholders no template
      prompt = prompt
        .replace('{{target}}', action.target || 'undefined')
        .replace('{{value}}', JSON.stringify(action.value) || 'undefined')
        .replace('{{options}}', JSON.stringify(action.options) || '{}');
      
      // Adicionar detalhes específicos da ação
      const actionDetails = JSON.stringify({
        type: action.type,
        target: action.target,
        value: action.value,
        options: action.options
      }, null, 2);
      
      prompt += `\n\nAction Details:\n${actionDetails}`;
      
      // Usar circuit breaker para chamar a API da Perplexity
      const response = await this.circuitBreaker.call(
        'perplexity-rpa',
        async () => {
          attempts++;
          
          return axios.post(
            `${this.baseUrl}/chat/completions`,
            {
              model: this.model,
              messages: [
                {
                  role: 'system',
                  content: 'You are an RPA specialist that generates precise step-by-step instructions for browser automation. Always respond with valid JavaScript code that can be executed in a Puppeteer environment.'
                },
                {
                  role: 'user',
                  content: prompt
                }
              ],
              temperature: 0.1,
              max_tokens: 1500
            },
            {
              headers: {
                'Authorization': `Bearer ${this.apiKey}`,
                'Content-Type': 'application/json'
              }
            }
          );
        },
        action.retries || 3
      );
      
      // Processar resposta
      const responseText = response.data.choices[0].message.content;
      const endTime = Date.now();
      
      // Extrair código JavaScript da resposta
      const codeMatch = responseText.match(/```javascript\n([\s\S]*?)\n```/) 
                       || responseText.match(/```js\n([\s\S]*?)\n```/);
      
      const actionCode = codeMatch ? codeMatch[1] : responseText;
      
      this.logger.info('RPA action generated', {
        actionType: action.type,
        target: action.target,
        executionTime: endTime - startTime
      });
      
      // Em um sistema real, este código seria executado em um ambiente de automação
      // Aqui, apenas simulamos o sucesso da operação
      
      return {
        success: true,
        data: { 
          code: actionCode,
          executionResult: "Action executed successfully" 
        },
        screenshot: "base64_encoded_screenshot_would_be_here",
        metrics: {
          startTime,
          endTime,
          attempts
        }
      };
    } catch (error) {
      const endTime = Date.now();
      
      this.logger.error('Error executing RPA action', {
        error,
        actionType: action.type,
        target: action.target
      });
      
      return {
        success: false,
        error: error as Error,
        metrics: {
          startTime,
          endTime,
          attempts
        }
      };
    }
  }

  async navigateTo(destination: string, options?: any): Promise<boolean> {
    const action: RpaAction = {
      type: 'navigate',
      target: destination,
      options: options
    };
    
    const result = await this.executeAction(action);
    return result.success;
  }

  async fillForm(formData: FormData, formSelector?: string): Promise<boolean> {
    const actions: RpaAction[] = [];
    
    // Criar ações para cada campo do formulário
    for (const [fieldId, value] of Object.entries(formData)) {
      actions.push({
        type: 'fill',
        target: fieldId,
        value: value,
        options: { formSelector }
      });
    }
    
    // Executar todas as ações em sequência
    const results = await this.executeSequence(actions);
    
    // Verificar se todas as ações foram bem-sucedidas
    return results.every(result => result.success);
  }

  async verifyResult(expected: any, options?: any): Promise<VerificationResult> {
    const action: RpaAction = {
      type: 'verify',
      value: expected,
      options: options
    };
    
    const result = await this.executeAction(action);
    
    if (!result.success) {
      return {
        verified: false,
        expectedValue: expected,
        screenshot: result.screenshot
      };
    }
    
    return {
      verified: true,
      expectedValue: expected,
      actualValue: result.data.actual,
      screenshot: result.screenshot
    };
  }

  async handleError(error: Error, context?: any): Promise<ErrorHandling> {
    // Implementação para lidar com erros durante execução RPA
    this.logger.error('RPA execution error', { error, context });
    
    const action: RpaAction = {
      type: 'custom',
      value: {
        operation: 'handle_error',
        error: error.message,
        context
      }
    };
    
    const result = await this.executeAction(action);
    
    if (!result.success) {
      return {
        resolved: false,
        recovery: 'abort',
        message: `Failed to handle error: ${error.message}`
      };
    }
    
    return {
      resolved: result.data.resolved,
      recovery: result.data.recovery,
      message: result.data.message,
      data: result.data.recoveryData
    };
  }

  async takeScreenshot(): Promise<string> {
    const action: RpaAction = {
      type: 'custom',
      value: { operation: 'take_screenshot' }
    };
    
    const result = await this.executeAction(action);
    
    if (!result.success || !result.screenshot) {
      throw new Error('Failed to take screenshot');
    }
    
    return result.screenshot;
  }

  async executeSequence(actions: RpaAction[]): Promise<RpaResult[]> {
    const results: RpaResult[] = [];
    
    for (const action of actions) {
      const result = await this.executeAction(action);
      results.push(result);
      
      // Parar a sequência se uma ação falhar
      if (!result.success) {
        break;
      }
    }
    
    return results;
  }
}

IMPLEMENTAÇÃO DO CORE
1. EnhancedEventBus.ts

import { v4 as uuidv4 } from 'uuid';
import { Logger } from './Logger';

export interface Event {
  type: string;
  payload: any;
  timestamp: number;
  id: string;
  metadata?: {
    priority?: number; // 1-5, sendo 1 a maior prioridade
    source?: string;
    correlationId?: string;
    retry?: number; // Contagem de retentativas
  };
}

export interface EventHandler {
  (event: Event): void | Promise<void>;
}

export interface EventSubscription {
  id: string;
  type: string;
  handler: EventHandler;
  priority: number;
}

export interface EventBusOptions {
  maxHistorySize?: number;
  enableDeadLetterQueue?: boolean;
  defaultPriority?: number;
  logEvents?: boolean;
  retryFailedEvents?: boolean;
  maxRetries?: number;
}

export class EnhancedEventBus {
  private handlers: Map<string, EventSubscription[]> = new Map();
  private history: Event[] = [];
  private deadLetterQueue: Event[] = [];
  private options: Required<EventBusOptions>;
  private logger: Logger;

  constructor(logger: Logger, options?: EventBusOptions) {
    this.logger = logger;
    this.options = {
      maxHistorySize: options?.maxHistorySize || 1000,
      enableDeadLetterQueue: options?.enableDeadLetterQueue ?? true,
      defaultPriority: options?.defaultPriority || 3,
      logEvents: options?.logEvents ?? true,
      retryFailedEvents: options?.retryFailedEvents ?? true,
      maxRetries: options?.maxRetries || 3
    };
  }

  initialize(): void {
    this.logger.info('EnhancedEventBus initialized', {
      options: this.options
    });
  }

  /**
   * Publica um evento no barramento
   * @param eventData Dados do evento a ser publicado
   * @returns ID único do evento publicado
   */
  publish(eventData: Omit<Event, 'id' | 'timestamp'>): string {
    const eventId = uuidv4();
    const timestamp = Date.now();
    
    const event: Event = {
      ...eventData,
      id: eventId,
      timestamp,
      metadata: {
        ...eventData.metadata,
        priority: eventData.metadata?.priority || this.options.defaultPriority
      }
    };
    
    if (this.options.logEvents) {
      this.logger.debug('Event published', {
        eventType: event.type,
        eventId,
        priority: event.metadata?.priority
      });
    }
    
    // Adicionar ao histórico
    this.addToHistory(event);
    
    // Processar evento de forma assíncrona
    setTimeout(() => this.processEvent(event), 0);
    
    return eventId;
  }

  /**
   * Inscreve um handler para receber eventos de um determinado tipo
   * @param type Tipo de evento (suporta wildcards com * e #)
   * @param handler Função de tratamento do evento
   * @param priority Prioridade do handler (1-5, sendo 1 a maior)
   * @returns Objeto de inscrição com ID
   */
  subscribe(type: string, handler: EventHandler, priority: number = 3): EventSubscription {
    const subscriptionId = uuidv4();
    const subscription: EventSubscription = {
      id: subscriptionId,
      type,
      handler,
      priority
    };
    
    if (!this.handlers.has(type)) {
      this.handlers.set(type, []);
    }
    
    const typeHandlers = this.handlers.get(type)!;
    typeHandlers.push(subscription);
    
    // Ordenar handlers por prioridade (menor número = maior prioridade)
    typeHandlers.sort((a, b) => a.priority - b.priority);
    
    this.logger.debug('Handler subscribed', {
      eventType: type,
      subscriptionId,
      priority
    });
    
    return subscription;
  }

  /**
   * Cancela a inscrição de um handler
   * @param subscription Objeto de inscrição ou ID da inscrição
   * @returns true se a inscrição foi cancelada, false caso contrário
   */
  unsubscribe(subscription: EventSubscription | string): boolean {
    const subscriptionId = typeof subscription === 'string' ? subscription : subscription.id;
    
    let found = false;
    
    // Percorrer todos os tipos de evento e remover a inscrição correspondente
    for (const [type, handlers] of this.handlers.entries()) {
      const index = handlers.findIndex(h => h.id === subscriptionId);
      
      if (index !== -1) {
        handlers.splice(index, 1);
        found = true;
        
        this.logger.debug('Handler unsubscribed', {
          eventType: type,
          subscriptionId
        });
        
        // Se não houver mais handlers para este tipo, remover a entrada
        if (handlers.length === 0) {
          this.handlers.delete(type);
        }
        
        break;
      }
    }
    
    return found;
  }

  /**
   * Obtém o histórico de eventos
   * @returns Lista de eventos
   */
  getHistory(): Event[] {
    return [...this.history];
  }

  /**
   * Obtém a fila de eventos com erro (Dead Letter Queue)
   * @returns Lista de eventos com erro
   */
  getDeadLetterQueue(): Event[] {
    return [...this.deadLetterQueue];
  }

  /**
   * Limpa o histórico de eventos
   */
  clearHistory(): void {
    this.history = [];
    this.logger.debug('Event history cleared');
  }

  /**
   * Limpa a fila de eventos com erro
   */
  clearDeadLetterQueue(): void {
    this.deadLetterQueue = [];
    this.logger.debug('Dead letter queue cleared');
  }

  /**
   * Reprocessa um evento da fila de eventos com erro
   * @param eventId ID do evento a ser reprocessado
   * @returns true se o evento foi encontrado e reprocessado, false caso contrário
   */
  reprocessDeadLetter(eventId: string): boolean {
    const index = this.deadLetterQueue.findIndex(e => e.id === eventId);
    
    if (index === -1) {
      return false;
    }
    
    const event = this.deadLetterQueue[index];
    this.deadLetterQueue.splice(index, 1);
    
    this.logger.info('Reprocessing dead letter', {
      eventType: event.type,
      eventId
    });
    
    // Resetar contagem de retentativas
    if (event.metadata) {
      event.metadata.retry = 0;
    }
    
    this.processEvent(event);
    return true;
  }

  /**
   * Adiciona um evento ao histórico, respeitando o tamanho máximo
   * @param event Evento a ser adicionado ao histórico
   */
  private addToHistory(event: Event): void {
    this.history.push(event);
    
    // Limitar o tamanho do histórico
    if (this.history.length > this.options.maxHistorySize) {
      this.history.shift();
    }
  }

  /**
   * Adiciona um evento à fila de eventos com erro
   * @param event Evento a ser adicionado à DLQ
   * @param error Erro ocorrido durante o processamento
   */
  private addToDeadLetterQueue(event: Event, error: any): void {
    if (!this.options.enableDeadLetterQueue) {
      return;
    }
    
    this.deadLetterQueue.push(event);
    
    this.logger.warn('Event moved to dead letter queue', {
      eventType: event.type,
      eventId: event.id,
      error: error.message
    });
  }

  /**
   * Processa um evento, chamando os handlers apropriados
   * @param event Evento a ser processado
   */
  private async processEvent(event: Event): Promise<void> {
    // Encontrar todos os handlers que devem processar este evento
    const matchingHandlers: EventSubscription[] = [];
    
    for (const [type, handlers] of this.handlers.entries()) {
      if (this.matchEventType(event.type, type)) {
        matchingHandlers.push(...handlers);
      }
    }
    
    // Ordenar todos os handlers selecionados por prioridade
    matchingHandlers.sort((a, b) => a.priority - b.priority);
    
    if (matchingHandlers.length === 0 && this.options.logEvents) {
      this.logger.debug('No handlers found for event', {
        eventType: event.type,
        eventId: event.id
      });
      return;
    }
    
    // Executar os handlers em ordem de prioridade
    for (const subscription of matchingHandlers) {
      try {
        await Promise.resolve(subscription.handler(event));
        
        if (this.options.logEvents) {
          this.logger.debug('Event handled successfully', {
            eventType: event.type,
            eventId: event.id,
            handlerId: subscription.id
          });
        }
      } catch (error) {
        this.logger.error('Error handling event', {
          eventType: event.type,
          eventId: event.id,
          handlerId: subscription.id,
          error
        });
        
        // Verificar se deve tentar novamente
        if (this.options.retryFailedEvents) {
          const retryCount = (event.metadata?.retry || 0) + 1;
          
          if (retryCount <= this.options.maxRetries) {
            // Atualizar contagem de retentativas
            const retryEvent: Event = {
              ...event,
              metadata: {
                ...(event.metadata || {}),
                retry: retryCount
              }
            };
            
            this.logger.info('Retrying event processing', {
              eventType: event.type,
              eventId: event.id,
              retryCount
            });
            
            // Escalonar a retentativa com backoff exponencial
            const delay = Math.pow(2, retryCount - 1) * 1000;
            setTimeout(() => this.processEvent(retryEvent), delay);
            return;
          }
        }
        
        // Se não deve tentar novamente ou esgotou as tentativas, adicionar à DLQ
        this.addToDeadLetterQueue(event, error);
      }
    }
  }

  /**
   * Verifica se um tipo de evento corresponde a um padrão de inscrição
   * Suporta wildcards:
   * - * (asterisco): qualquer segmento único
   * - # (hash): qualquer número de segmentos
   * @param eventType Tipo do evento publicado
   * @param patternType Padrão de inscrição
   * @returns true se o tipo corresponder ao padrão, false caso contrário
   */
  private matchEventType(eventType: string, patternType: string): boolean {
    // Caso simples: tipos idênticos
    if (eventType === patternType) {
      return true;
    }
    
    // Dividir os tipos em segmentos
    const eventSegments = eventType.split('.');
    const patternSegments = patternType.split('.');
    
    let eventIndex = 0;
    let patternIndex = 0;
    
    while (eventIndex < eventSegments.length && patternIndex < patternSegments.length) {
      const patternSegment = patternSegments[patternIndex];
      
      // Wildcard #: corresponde a qualquer número de segmentos restantes
      if (patternSegment === '#') {
        return true;
      }
      
      // Wildcard *: corresponde a exatamente um segmento
      if (patternSegment === '*') {
        eventIndex++;
        patternIndex++;
        continue;
      }
      
      // Segmento normal: deve corresponder exatamente
      if (eventSegments[eventIndex] !== patternSegment) {
        return false;
      }
      
      eventIndex++;
      patternIndex++;
    }
    
    // Verificar se ambos os índices chegaram ao fim
    // (permitindo um # final no padrão)
    return (
      (eventIndex === eventSegments.length && patternIndex === patternSegments.length) ||
      (patternIndex === patternSegments.length - 1 && patternSegments[patternIndex] === '#')
    );
  }
}

2. CircuitBreakerService.ts

import { Logger } from './Logger';

export enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

export interface CircuitBreakerOptions {
  failureThreshold: number;
  resetTimeout: number;
  halfOpenSuccessThreshold: number;
  maxRetries?: number;
  retryBackoff?: number;
  timeout?: number;
}

export interface CircuitStats {
  state: CircuitState;
  failures: number;
  successes: number;
  lastFailure: Date | null;
  lastSuccess: Date | null;
  totalRequests: number;
  totalFailures: number;
  totalSuccesses: number;
  openCircuitTimestamp: Date | null;
}

export class CircuitBreakerService {
  private readonly circuits: Map<string, {
    state: CircuitState;
    failures: number;
    successes: number;
    lastFailure: Date | null;
    lastSuccess: Date | null;
    lastStateChange: Date;
    resetTimeout: NodeJS.Timeout | null;
    options: Required<CircuitBreakerOptions>;
    totalRequests: number;
    totalFailures: number;
    totalSuccesses: number;
    openCircuitTimestamp: Date | null;
  }> = new Map();

  private readonly defaultOptions: Required<CircuitBreakerOptions> = {
    failureThreshold: 5,
    resetTimeout: 30000, // 30 segundos
    halfOpenSuccessThreshold: 2,
    maxRetries: 3,
    retryBackoff: 1000, // 1 segundo (multiplicado pelo número da tentativa)
    timeout: 10000 // 10 segundos
  };

  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Configura um circuit breaker para um serviço específico
   * @param service Nome do serviço
   * @param options Opções de configuração
   */
  configure(service: string, options?: Partial<CircuitBreakerOptions>): void {
    const existingCircuit = this.circuits.get(service);
    
    if (existingCircuit) {
      existingCircuit.options = {
        ...existingCircuit.options,
        ...options
      };
      return;
    }
    
    this.circuits.set(service, {
      state: CircuitState.CLOSED,
      failures: 0,
      successes: 0,
      lastFailure: null,
      lastSuccess: null,
      lastStateChange: new Date(),
      resetTimeout: null,
      options: {
        ...this.defaultOptions,
        ...options
      },
      totalRequests: 0,
      totalFailures: 0,
      totalSuccesses: 0,
      openCircuitTimestamp: null
    });
    
    this.logger.info('Circuit breaker configured', {
      service,
      initialState: CircuitState.CLOSED,
      options: { ...this.defaultOptions, ...options }
    });
  }

  /**
   * Executa uma função com proteção de circuit breaker
   * @param service Nome do serviço
   * @param fn Função a ser executada
   * @param retries Número de tentativas já realizadas
   * @returns Resultado da função
   * @throws Error se o circuit breaker estiver aberto ou a função falhar
   */
  async call<T>(service: string, fn: () => Promise<T>, retries: number = 0): Promise<T> {
    // Configurar circuito se ainda não existir
    if (!this.circuits.has(service)) {
      this.configure(service);
    }
    
    const circuit = this.circuits.get(service)!;
    circuit.totalRequests++;
    
    // Verificar se o circuito está aberto
    if (circuit.state === CircuitState.OPEN) {
      this.logger.warn('Circuit is OPEN, rejecting request', {
        service,
        lastFailure: circuit.lastFailure,
        failures: circuit.failures,
        openCircuitTimestamp: circuit.openCircuitTimestamp
      });
      
      throw new Error(`Circuit breaker is open for service: ${service}`);
    }
    
    try {
      // Aplicar timeout se configurado
      let result: T;
      
      if (circuit.options.timeout > 0) {
        result = await this.promiseWithTimeout(fn(), circuit.options.timeout);
      } else {
        result = await fn();
      }
      
      // Sucesso!
      this.onSuccess(service);
      return result;
    } catch (error) {
      // Falha na execução
      this.onFailure(service);
      
      // Tentar novamente se possível
      if (retries < circuit.options.maxRetries) {
        const nextRetry = retries + 1;
        const backoff = circuit.options.retryBackoff * nextRetry;
        
        this.logger.info('Retrying request after failure', {
          service,
          retry: nextRetry,
          maxRetries: circuit.options.maxRetries,
          backoff
        });
        
        await new Promise(resolve => setTimeout(resolve, backoff));
        return this.call(service, fn, nextRetry);
      }
      
      // Propagar o erro original
      throw error;
    }
  }

  /**
   * Obtém as estatísticas de um circuit breaker
   * @param service Nome do serviço
   * @returns Estatísticas do circuit breaker
   */
  getStats(service: string): CircuitStats | null {
    const circuit = this.circuits.get(service);
    
    if (!circuit) {
      return null;
    }
    
    return {
      state: circuit.state,
      failures: circuit.failures,
      successes: circuit.successes,
      lastFailure: circuit.lastFailure,
      lastSuccess: circuit.lastSuccess,
      totalRequests: circuit.totalRequests,
      totalFailures: circuit.totalFailures,
      totalSuccesses: circuit.totalSuccesses,
      openCircuitTimestamp: circuit.openCircuitTimestamp
    };
  }

  /**
   * Obtém o estado atual de um circuit breaker
   * @param service Nome do serviço
   * @returns Estado do circuit breaker
   */
  getState(service: string): CircuitState | null {
    return this.circuits.get(service)?.state || null;
  }

  /**
   * Reseta um circuit breaker para o estado fechado
   * @param service Nome do serviço
   */
  reset(service: string): void {
    const circuit = this.circuits.get(service);
    
    if (!circuit) {
      return;
    }
    
    // Cancelar timeout de reset se existir
    if (circuit.resetTimeout) {
      clearTimeout(circuit.resetTimeout);
      circuit.resetTimeout = null;
    }
    
    circuit.state = CircuitState.CLOSED;
    circuit.failures = 0;
    circuit.successes = 0;
    circuit.lastStateChange = new Date();
    circuit.openCircuitTimestamp = null;
    
    this.logger.info('Circuit breaker reset', {
      service,
      newState: CircuitState.CLOSED
    });
  }

  /**
   * Manipula um sucesso em uma chamada
   * @param service Nome do serviço
   */
  private onSuccess(service: string): void {
    const circuit = this.circuits.get(service)!;
    circuit.lastSuccess = new Date();
    circuit.totalSuccesses++;
    
    // No estado semi-aberto, verificar se atingiu o limite de sucessos
    if (circuit.state === CircuitState.HALF_OPEN) {
      circuit.successes++;
      
      if (circuit.successes >= circuit.options.halfOpenSuccessThreshold) {
        this.transitionToState(service, CircuitState.CLOSED);
      }
    }
    
    // No estado fechado, resetar contagem de falhas
    if (circuit.state === CircuitState.CLOSED) {
      circuit.failures = 0;
    }
  }

  /**
   * Manipula uma falha em uma chamada
   * @param service Nome do serviço
   */
  private onFailure(service: string): void {
    const circuit = this.circuits.get(service)!;
    circuit.lastFailure = new Date();
    circuit.totalFailures++;
    
    // No estado semi-aberto, voltar para aberto
    if (circuit.state === CircuitState.HALF_OPEN) {
      this.transitionToState(service, CircuitState.OPEN);
      return;
    }
    
    // No estado fechado, verificar se atingiu o limite de falhas
    if (circuit.state === CircuitState.CLOSED) {
      circuit.failures++;
      
      if (circuit.failures >= circuit.options.failureThreshold) {
        this.transitionToState(service, CircuitState.OPEN);
      }
    }
  }

  /**
   * Muda o estado de um circuit breaker
   * @param service Nome do serviço
   * @param newState Novo estado
   */
  private transitionToState(service: string, newState: CircuitState): void {
    const circuit = this.circuits.get(service)!;
    const oldState = circuit.state;
    
    if (oldState === newState) {
      return;
    }
    
    circuit.state = newState;
    circuit.lastStateChange = new Date();
    
    this.logger.info('Circuit breaker state changed', {
      service,
      oldState,
      newState
    });
    
    // Ações específicas para cada transição
    if (newState === CircuitState.OPEN) {
      circuit.openCircuitTimestamp = new Date();
      circuit.failures = 0;
      circuit.successes = 0;
      
      // Configurar timeout para transição para semi-aberto
      circuit.resetTimeout = setTimeout(() => {
        this.transitionToState(service, CircuitState.HALF_OPEN);
      }, circuit.options.resetTimeout);
    } else if (newState === CircuitState.HALF_OPEN) {
      circuit.failures = 0;
      circuit.successes = 0;
      
      if (circuit.resetTimeout) {
        clearTimeout(circuit.resetTimeout);
        circuit.resetTimeout = null;
      }
    } else if (newState === CircuitState.CLOSED) {
      circuit.failures = 0;
      circuit.successes = 0;
      
      if (circuit.resetTimeout) {
        clearTimeout(circuit.resetTimeout);
        circuit.resetTimeout = null;
      }
      
      circuit.openCircuitTimestamp = null;
    }
  }

  /**
   * Executa uma promise com timeout
   * @param promise Promise a ser executada
   * @param timeout Tempo limite em milissegundos
   * @returns Resultado da promise
   * @throws Error se o tempo limite for atingido
   */
  private async promiseWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {
    let timeoutId: NodeJS.Timeout;
    
    const timeoutPromise = new Promise<never>((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new Error(`Operation timed out after ${timeout}ms`));
      }, timeout);
    });
    
    try {
      // Race entre a promise original e o timeout
      return await Promise.race([promise, timeoutPromise]);
    } finally {
      clearTimeout(timeoutId!);
    }
  }
}

3. Logger.ts

import winston from 'winston';

export enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug'
}

export interface LoggerOptions {
  level?: LogLevel;
  consoleEnabled?: boolean;
  fileEnabled?: boolean;
  fileDir?: string;
  filename?: string;
  maxSize?: number;
  maxFiles?: number;
}

export class Logger {
  private logger: winston.Logger;
  private options: Required<LoggerOptions>;

  constructor(options?: LoggerOptions) {
    this.options = {
      level: options?.level || LogLevel.INFO,
      consoleEnabled: options?.consoleEnabled ?? true,
      fileEnabled: options?.fileEnabled ?? true,
      fileDir: options?.fileDir || 'logs',
      filename: options?.filename || 'application-%DATE%.log',
      maxSize: options?.maxSize || 10 * 1024 * 1024, // 10MB
      maxFiles: options?.maxFiles || 7 // 7 dias
    };

    const transports: winston.transport[] = [];

    // Console transport
    if (this.options.consoleEnabled) {
      transports.push(new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.timestamp(),
          winston.format.printf(({ timestamp, level, message, ...meta }) => {
            const ts = new Date(timestamp).toISOString();
            const metaStr = Object.keys(meta).length ? `\n${JSON.stringify(meta, null, 2)}` : '';
            return `${ts} ${level}: ${message}${metaStr}`;
          })
        )
      }));
    }

    // File transport
    if (this.options.fileEnabled) {
      transports.push(new winston.transports.File({
        dirname: this.options.fileDir,
        filename: this.options.filename,
        maxsize: this.options.maxSize,
        maxFiles: this.options.maxFiles,
        format: winston.format.combine(
          winston.format.timestamp(),
          winston.format.json()
        )
      }));
    }

    this.logger = winston.createLogger({
      level: this.options.level,
      levels: winston.config.npm.levels,
      transports
    });
  }

  error(message: string, meta?: Record<string, any>): void {
    this.logger.error(message, meta);
  }

  warn(message: string, meta?: Record<string, any>): void {
    this.logger.warn(message, meta);
  }

  info(message: string, meta?: Record<string, any>): void {
    this.logger.info(message, meta);
  }

  debug(message: string, meta?: Record<string, any>): void {
    this.logger.debug(message, meta);
  }

  setLevel(level: LogLevel): void {
    this.options.level = level;
    this.logger.level = level;
  }

  getLevel(): LogLevel {
    return this.options.level;
  }
}

4. AICoordinator.ts

import { v4 as uuidv4 } from 'uuid';
import { IStrategicIntelligence, Result } from '../interfaces/IStrategicIntelligence';
import { IRpaExecutor, RpaAction, RpaResult } from '../interfaces/IRpaExecutor';
import { Logger } from '../../utils/Logger';
import { EnhancedEventBus, Event } from '../../utils/EnhancedEventBus';

export interface AIMessage {
  id: string;
  source: 'strategic' | 'rpa';
  type: string;
  payload: any;
  timestamp: number;
}

export interface RequestOptions {
  priority?: number;
  timeout?: number;
  retries?: number;
  context?: any;
}

export class AICoordinator {
  private strategicIntelligence: IStrategicIntelligence;
  private rpaExecutor: IRpaExecutor;
  private logger: Logger;
  private eventBus: EnhancedEventBus;
  private pendingRequests: Map<string, {
    resolve: (value: any) => void;
    reject: (reason: any) => void;
    timeout: NodeJS.Timeout | null;
    options: RequestOptions;
  }> = new Map();
  private messageHandlers: Map<string, (message: AIMessage) => void> = new Map();

  constructor(
    strategicIntelligence: IStrategicIntelligence,
    rpaExecutor: IRpaExecutor,
    logger: Logger,
    eventBus: EnhancedEventBus
  ) {
    this.strategicIntelligence = strategicIntelligence;
    this.rpaExecutor = rpaExecutor;
    this.logger = logger;
    this.eventBus = eventBus;
  }

  async initialize(): Promise<void> {
    await this.strategicIntelligence.initialize();
    await this.rpaExecutor.initialize();
    
    // Inscrever-se para eventos relevantes
    this.eventBus.subscribe('ai.message', this.handleAIMessageEvent.bind(this), 1);
    
    this.logger.info('AICoordinator initialized');
  }

  async sendToStrategicIntelligence(data: any, options: RequestOptions = {}): Promise<Result> {
    const requestId = uuidv4();
    
    this.logger.debug('Sending request to Strategic Intelligence', {
      requestId,
      dataType: typeof data,
      options
    });
    
    // Publicar evento para processamento
    this.eventBus.publish({
      type: 'ai.strategic.request',
      payload: {
        requestId,
        data,
        options
      },
      metadata: {
        priority: options.priority || 3
      }
    });
    
    // Aguardar resposta assíncrona
    return this.waitForResponse(requestId, options.timeout || 60000) as Promise<Result>;
  }

  async sendToRpaExecutor(
    action: RpaAction | RpaAction[],
    options: RequestOptions = {}
  ): Promise<RpaResult | RpaResult[]> {
    const requestId = uuidv4();
    const isSequence = Array.isArray(action);
    
    this.logger.debug('Sending request to RPA Executor', {
      requestId,
      actionType: isSequence ? 'sequence' : action.type,
      options
    });
    
    // Publicar evento para processamento
    this.eventBus.publish({
      type: 'ai.rpa.request',
      payload: {
        requestId,
        action,
        isSequence,
        options
      },
      metadata: {
        priority: options.priority || 3
      }
    });
    
    // Aguardar resposta assíncrona
    return this.waitForResponse(requestId, options.timeout || 120000) as Promise<RpaResult | RpaResult[]>;
  }

  waitForResponse(id: string, timeout: number = 60000): Promise<any> {
    return new Promise((resolve, reject) => {
      // Configurar timeout para rejeição automática
      const timeoutId = setTimeout(() => {
        const request = this.pendingRequests.get(id);
        
        if (request) {
          this.pendingRequests.delete(id);
          reject(new Error(`Request timed out after ${timeout}ms (ID: ${id})`));
          
          this.logger.warn('Request timed out', {
            requestId: id,
            timeout
          });
        }
      }, timeout);
      
      // Armazenar a promise pendente
      this.pendingRequests.set(id, {
        resolve,
        reject,
        timeout: timeoutId,
        options: { timeout }
      });
    });
  }

  /**
   * Manipula mensagens internas do sistema de IA
   * @param message Mensagem a ser processada
   */
  handleAIMessage(message: AIMessage): void {
    this.logger.debug('AI message received', {
      messageId: message.id,
      source: message.source,
      type: message.type
    });
    
    // Executar todos os handlers registrados
    for (const handler of this.messageHandlers.values()) {
      try {
        handler(message);
      } catch (error) {
        this.logger.error('Error in message handler', {
          error,
          messageId: message.id
        });
      }
    }
    
    // Publicar evento para processamento adicional
    this.eventBus.publish({
      type: 'ai.message',
      payload: message,
      metadata: {
        priority: 2 // Alta prioridade para mensagens internas
      }
    });
  }

  /**
   * Manipulador de eventos para mensagens de IA
   * @param event Evento a ser processado
   */
  private async handleAIMessageEvent(event: Event): Promise<void> {
    const message = event.payload as AIMessage;
    
    // Verificar se está relacionado a uma solicitação pendente
    if (message.type === 'strategic.response' || message.type === 'rpa.response') {
      const requestId = message.payload.requestId;
      const request = this.pendingRequests.get(requestId);
      
      if (request) {
        // Cancelar timeout
        if (request.timeout) {
          clearTimeout(request.timeout);
        }
        
        // Resolver ou rejeitar a promise pendente
        if (message.payload.error) {
          request.reject(new Error(message.payload.error));
        } else {
          request.resolve(message.payload.result);
        }
        
        // Remover a solicitação pendente
        this.pendingRequests.delete(requestId);
        
        this.logger.debug('Request completed', {
          requestId,
          success: !message.payload.error
        });
      }
    }
  }

  /**
   * Registra um handler para receber mensagens do sistema de IA
   * @param handler Função de tratamento da mensagem
   * @returns ID único do handler registrado
   */
  registerMessageHandler(handler: (message: AIMessage) => void): string {
    const handlerId = uuidv4();
    this.messageHandlers.set(handlerId, handler);
    return handlerId;
  }

  /**
   * Remove um handler registrado
   * @param id ID do handler a ser removido
   * @returns true se o handler foi removido, false caso contrário
   */
  unregisterMessageHandler(id: string): boolean {
    return this.messageHandlers.delete(id);
  }
}

## FASE 7: PONTOS DE VERIFICAÇÃO E MÉTRICAS DE VALIDAÇÃO

**Mensagem para copiar e colar:**

PONTOS DE VERIFICAÇÃO E MÉTRICAS DE VALIDAÇÃO

Para garantir que a implementação está avançando corretamente, estabeleça estes pontos de verificação ao longo do desenvolvimento:
PONTOS DE VERIFICAÇÃO CRÍTICOS
1. VERIFICAÇÃO DO CORE (Sprint 1-2)

    Teste do EnhancedEventBus:
        Publicar eventos com diferentes prioridades e verificar ordem de processamento
        Verificar roteamento de eventos com tópicos hierárquicos
        Testar Dead Letter Queue e reprocessamento de eventos

    Teste do CircuitBreaker:
        Verificar transição entre os três estados (CLOSED → OPEN → HALF_OPEN → CLOSED)
        Confirmar que requisições são bloqueadas no estado OPEN
        Testar recuperação automática após reset timeout

    Teste do Sistema de IA Dual:
        Verificar inicialização do AICoordinator com serviços de IA
        Testar chamadas para Claude e verificar análises retornadas
        Testar chamadas para Perplexity e verificar instruções RPA geradas

2. VERIFICAÇÃO DO DROPHUNTER (Sprint 3-4)

    Teste do Pipeline de Descoberta:
        Verificar coleta de dados de pelo menos 3 fontes diferentes
        Validar normalização de dados em formato comum
        Confirmar que os filtros estão sendo aplicados corretamente

    Teste do Sistema de Análise:
        Verificar aplicação do framework de 8 fatores
        Confirmar cálculo correto de pontuação do produto
        Validar classificação em tiers (Platinum, Gold, Silver, Bronze, Rejected)

    Teste da Análise de Mercado:
        Verificar análise específica por país
        Validar segmentação demográfica
        Confirmar cálculo de ROI potencial

3. VERIFICAÇÃO DO ROBOTHGADS (Sprint 5-7)

    Teste da Especificação de Campanha:
        Verificar geração de especificações completas
        Validar estrutura da campanha gerada
        Confirmar que templates estão sendo aplicados corretamente

    Teste da Gestão de Contas:
        Verificar lógica de seleção de contas
        Validar transições entre estágios do ciclo de vida
        Confirmar cálculo de health score

    Teste da Execução RPA:
        Verificar geração de instruções RPA
        Validar execução e verificação de resultados
        Confirmar tratamento de erros e recuperação

MÉTRICAS DE VALIDAÇÃO

A implementação será considerada bem-sucedida se atender aos seguintes critérios:
1. Integridade de Implementação

    100% de cobertura de componentes: Todos os componentes especificados no plano devem ser implementados
    100% de aderência a interfaces: Todas as interfaces devem ser implementadas conforme especificado
    0 desvios arquiteturais: Manter a arquitetura hexagonal estritamente

2. Qualidade de Código

    >90% de cobertura de testes: Testes unitários e de integração
    0 erros de linting: Seguir padrões de estilo de código
    Documentação completa: Todas as classes, métodos e interfaces com JSDoc

3. Funcionalidade

    Pipeline completo funcionando: Produto descoberto → Analisado → Campanha criada
    Framework de 8 Fatores implementado: Classificação precisa de produtos
    Ciclo de Vida de 3 Estágios implementado: Transições funcionais entre estágios

4. Performance

    Tempo de análise < 60s: Produto completo analisado em menos de 60 segundos
    Tempo de especificação < 90s: Campanha especificada em menos de 90 segundos
    Tempo de criação < 120s: Campanha criada em menos de 120 segundos

ENTREGÁVEIS FINAIS

Ao final da implementação, os seguintes entregáveis devem estar prontos:

    Repositório de código completo:
        Todos os componentes implementados
        Testes unitários e de integração
        Documentação completa

    Documentação do sistema:
        Guia de instalação e configuração
        Diagrama de arquitetura detalhado
        Documentação de APIs

    Script de demonstração:
        Pipeline completo funcionando
        Exemplos de produtos e campanhas
        Dashboard de métricas

    Configuração de templates:
        Templates base implementados
        Templates de especialistas configurados
        Templates específicos por país e nicho

## FASE 8: INSTRUÇÕES FINAIS E ENTREGA

**Mensagem para copiar e colar:**

INSTRUÇÕES FINAIS E CONSIDERAÇÕES PARA ENTREGA

Conforme você avança na implementação do ROBOTHGADS + DROPHUNTER, mantenha estas considerações finais em mente:
ASPECTOS CRÍTICOS DE IMPLEMENTAÇÃO

    Segurança e Tratamento de Credenciais:
        Nunca codifique chaves de API diretamente no código
        Utilize variáveis de ambiente para todas as credenciais
        Implemente obscurecimento de dados sensíveis nos logs

    Tratamento de Erros Robusto:
        Todas as funções devem ter tratamento de erros apropriado
        Implementar estratégias de retry com backoff
        Garantir que falhas em um componente não afetem todo o sistema

    Logging Extensivo:
        Cada componente deve ter logging adequado
        Incluir informações contextuais em todos os logs
        Garantir rastreabilidade completa das operações

    Configuração Flexível:
        Todos os parâmetros críticos devem ser configuráveis
        Implementar carregamento de configuração em camadas
        Permitir sobrescrever configurações em runtime

PROCESSO DE ENTREGA

    Entrega Incremental:
        Entregar componentes funcionais a cada sprint
        Priorizar o núcleo funcional e expandir gradualmente
        Manter documentação atualizada em cada entrega

    Testes Automatizados:
        Implementar testes unitários para todos os componentes
        Desenvolver testes de integração para fluxos completos
        Configurar CI/CD para execução automática de testes

    Documentação Final:
        Documentação de API para todos os componentes
        Diagrama detalhado da arquitetura implementada
        Guia de configuração e troubleshooting

QUALIDADE DE CÓDIGO

    Estilo e Consistência:
        Seguir um padrão de codificação consistente
        Utilizar linting para garantir conformidade
        Manter nomes de variáveis e funções semânticos

    Modularidade e Coesão:
        Cada componente deve ter uma responsabilidade clara
        Minimizar dependências entre componentes
        Favorecer composição sobre herança

    Performance:
        Identificar e otimizar hotspots de performance
        Implementar caching onde apropriado
        Monitorar uso de memória e CPU

ÚLTIMA VERIFICAÇÃO ANTES DA ENTREGA

Antes de finalizar a implementação, verifique:

    Completude da Implementação:
        Todos os componentes especificados foram implementados
        Todas as interfaces estão completamente implementadas
        Não há TODOs ou implementações parciais no código

    Qualidade Global:
        Cobertura de testes adequada
        Documentação completa e atualizada
        Código limpo e bem estruturado

    Validação de Fluxos:
        O fluxo completo de descoberta ao anúncio funciona
        Todos os pontos de integração estão funcionando
        O sistema é resiliente a falhas

ENTREGA FINAL

A entrega final deve incluir:

    Repositório de Código:
        Código-fonte completo e organizado
        Scripts de build e deploy
        Arquivos de configuração de exemplo

    Documentação Técnica:
        Detalhamento da arquitetura implementada
        Guia de instalação e configuração
        API Reference para todos os componentes

    Documentação de Usuário:
        Manual de operação do sistema
        Guia de troubleshooting
        Descrição de fluxos de trabalho

    Roadmap de Evolução:
        Identificação de melhorias futuras
        Priorização de novas funcionalidades
        Considerações para escalabilidade

